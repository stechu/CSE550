\documentclass[11pt, onecolumn]{article}
\usepackage[pdftex]{graphicx}
\usepackage{wrapfig}
\usepackage{enumerate}
\usepackage{hyperref}

\begin{document}

\title{CSE550 Problem Set 2: Paxos Design Document}
\author{Vincent Lee, Shumo Chu}
\date{\today}

\maketitle

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Intro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

In this document, we outlined our software implementation of the Paxos consensus protocol explained in TODO: ADD REFERENCE.
We present a high level software architecture, justify our design decisions, and explain any simplfying assumptions that we make to our design.
We then explain how to use our implementation, and any outstanding problems with our implementation.
A quick discussion of any interesting tidbits we encounter concludes the document.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Paxos Protocol Summary
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Paxos Protocol}

The Paxos protocol originally proposed by Lamport in TODO: ADD REFERENCE is a consensus protocol designed to make forward progress even in the face of arbitrary failures.
We interpret consensus to be defined as the following constraints:

\begin{enumerate}
\item One and only one value may be chosen per Paxos instance
\item The value must come from the set of proposals
\item Only the chosen values can propagate to learners
\end{enumerate}

The Paxos protocol consists of three classes of members: proposers, acceptors, and learners.
Proposers are defined as entities that present proposals to acceptors.
Acceptors are defined as entities that are responsible for arbitrating whether a proposal is accepted or not.
Finally, learners are defined as entities that are subscribed to a particular value that a consensus determines.

In any Paxos instance, in order to tolerate node failure, multiple proposers and acceptors participate in a Paxos instance.
A Paxos instance is resolved by the following a two phase protocol.

In the first phase of the protocol, proposers create proposals with some associated monotonically increasing sequence number N. 
The sequence number is always larger than any previous sequence number the proposer has issued. 
A propose message is then sent to the set of acceptors with the sequence number chosen. 
When an acceptor receives a propose message, it compares the sequence number of the proposal to all previous sequence numbers it has seen.
If the sequence number received is less than any sequence number the acceptor has seen, the proposal is rejected and ignored.
If the sequence number received by the acceptor is greater than or equal to the prior sequence numbers observed by the acceptor, it ``promises'' to reject all messages less than the sequence number received from that point forward.
A response is issued with this ``promise'' to the original proposer.

Meanwhile, the original proposer wait until it receives responses from a majority of the acceptors it initially issued proposals to with sequence number N.
Once this occurs, the proposer issues another message with the value chosen for the proposal that was issued.
An acceptor will accept the proposal and chosen value if the highest sequence number is sees is still N, and reject the message otherwise.
Upon successful receipt of the accept message, messages are issued to all relevant learners with the value chosen and an accept message is issued to the original proposer.
If an acceptor rejects the message, the message will be discarded and no response will be issued.
A proposer knows its attempt to chose a value has failed if it does not receive responses from a majority of acceptors.

If at the end of a single iteration of this protocol, no value is ultimately chosen, the procedure is repeated with a higher sequence number of each node until a value is eventually chosen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Implementation Details
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Paxos Implementation of Lock Service}

Our design leverages the Paxos algorithm to implement a the ordering of commands for a simple lock service.
Issuable commands in this service are \bf{lock(x)} and \bf{unlock(x)} where \bf{x} is an integer.
The end goal of this service is to provide consensus upon a series of commands in which locks are resolved in a valid order.
The state machine in this service is defined to be the state of the locks and is replicated across servers for resilience to failure.
Each instance of the Paxos protocol resolves exactly one command to be issued for that instance.
Instances are numbered in monotonically increasing order and correlate to sequence in which the \bf{lock(x)} and \bf{unlock(x)} commands are issued.

\subsection{Simplifying Assumptions}

We assume the same assumptions about the distributed system model as originally proposed in the Paxos paper. Namely, we assume the following:

\begin{enumerate}
\item No Byzantine failures will occur.
\item All entities in the distributed system operate asynchronously at arbitrary speed
\item Any node that fails in the system will observe fail-stop behavior
\item Messages at any phase during the protocol can be dropped, reordered, or duplicated
\end{enumerate}

We also make the following assumptions to simplify our implementation of the Paxos algorithm:

\begin{enumerate}
\item Any nodes that experience a failure will permanently be removed from the Paxos group and will not attempt recovery and restart
\item Clients to the system will not intentionally behave maliciously
\item Entities will not attempt to retransmit messages in the case of message loss or timeout
\item Clients know which entities are part of the Paxos group
\item The client-server communication channel is reliable
\end{enumerate}


TODO: figure out how to elect a leader

\subsection{Failure Mode Considerations}

The following is a list of failure modes that our implementation of the lock service considers:

\begin{enumerate}
\item Upon a connection by the client, the Paxos member servicing the client requests promptly fails. 
  We resolve this by tagging client requests with a unique identifier.
  The unique identifier is used upon reconnecting to a new Paxos member to validate whether requests by the failed Paxos member were accepted.
  If a command with the unique identifier appears in a previous resolution to an instance of Paxos, we know that the command has already been accepted and do not need to attempt to propose it again.
  If the command identifier does not appear in the list of previously resolved Paxos instances, we know that the original proposal failed and must be proposed again.
\item Upon acquiring a lock, the client connection and the lock is orphaned. 
  We do not handle this in our implementation as we assume that clients are well behaved and communication between the client and server is reliable
\item Upon acquiring a lock, the server node dies and the lock is orphaned.
  We consider allowing the client to reconnect to a different server node to complete execution of the lock sequence to free the lock.
  Clients will issue a client identifier tag with each request allowing the server to authenticate if the client was the original holder of the lock.
\end{enumerate}

\subsection{High Level Software Architecture}

We first note that it is necessary for each Paxos process to act as a proposer, acceptor, and learner as suggested by Lamport in ``Paxos Made Simple''.
This is because there are multiple instances of Paxos that may be running and so new proposals must be attributed to instance numbers that have not yet been resolved.
Proposers and learners in particular must reside on the same process because only learners are defined to learn the outcome on a Paxos instance.
A proposer must know which instances of Paxos have been resolved so that it may make a proposal for an instance that has not been resolved and therefore must also be a learner.
This architecture also eliminates the possibility that proposer's receive an accept request acknowledgement while learners may not due to catastrophic message losses.
By making a process both an acceptor and a learner, it is guaranteed that both the acceptor and learner get a majority response or that both fail to get a majority response.

\subsection{Implementation Details}

\subsubsection{Server Initialization}

We use a script to initialize each of our servers and bring our Paxos group online.
Each server is initialized with a unique server identifier and a list of hostname and ports for all other servers in the Paxos group to establish communication channels.
This is also to allow each server to independently compute a mutually indepedent set of monotonically increasing proposals numbers and avoid proposal number collisions.
These server connection channels are used to communicate messages between Paxos members and is an all-to-all network.
To ensure safe bring up, we first initialize listening sockets on each server, then initialize the connections betwen servers.
Each server in addition to inter-server communication channel sockets, exposes a client facing server socket which are used exclusively by clients to connect to.
This architecture decision was to simplify the message handling and control complexity that would have gone in to processing both client state and Paxos member states during the protocol.
To avoid port collision, listening socket numbers on each server are predefined.

\subsubsection{Message Passing}

A message data structure is used to contain the contents of any message traveling to and between the Paxos group members.
The message type determines how the message should be interpreted; message types are: PREPARE, PREPARE\_ACK, ACCEPT, ACCEPT\_ACK, CLIENT, CLIENT\_ACK.
A explanation of each message type is below:
\begin{itemize}
\item PREPARE - indicates message is a prepare request from a proposer; holds the proposal number, instance number, and the origin server
\item PREPARE\_ACK - indicates message ia an acknowledgement or promise message for a proposer from an acceptor; holds a proposal number, and instance number
\item ACCEPT - an accept request message; holds a proposal number, instance number, value, and origin
\item ACCEPT\_ACK - an accept acknowledgement; sends proposal number, instance number, and value
\item CLIENT - indicates message came from client with a command request; contains value
\item CLIENT\_ACK - an acknowledgement message send to the client once command proposed has been accepted
\end{itemize}

Each server runs two communication server channels.
One server socket is dedicated to receiving and connecting to exclusively other servers
A second server socket is dedicated to listening to client connections on the proposer process discussed later.
To avoid port collisions, each server assumes that the port number supplied during initialization and the port number plus 1 are both allocated for that server.

\begin{figure}
\includegraphics[width=6in]{paxos_group_connections.jpg}
\caption{Paxos Group Connections - each Paxos group member holds connections to clients and connections to communication to every other server in the Paxos group} 
\end{figure}

Once a command has been successfully added to an instance of Paxos, an acknowledgement message is sent to the client notifying the client that the lock was acquired. The connection then waits until a new command is issued by the client and repeats the processing or the client terminates the connection.

\subsection{Process Architecture}

A server contains one instance of each Paxos role: a proposer, an acceptor, and a learner.
The proposer, acceptor, and learners run on separate processes for each instance of a server in order to operate asynchronously.
Each process has a message queue which is fed with in-bound messages from other servers and client requests.
A listening thread is initialized on the inter-server socket which receives messages and routes them
The proposer process is responsible for opening a client facing socket which allows clients to connect to the service and send request messages.
Proposers handle each connection in a blocking manner where the client connection will block until the requested command issued by the client makes it into an instance of Paxos.

\begin{figure}
\includegraphics[width=4in]{paxos_member_architecture.jpg}
\caption{Process Architecture - message queues to learner, proposer, and acceptor are serialized and each put() on the message queue is atomic}
\end{figure}


\subsection{Lock Service Contention}

Because the service for each client is blocking until the request is resolved, in the event of lock contention a client connection will simply wait until lock request has been processed.

TODO: argue correctness?

STUB




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Instructions for Use
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{How to Use Our Implementation}

STUB

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Known Issues
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Known Issues}

STUB

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Discussion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Discussion}

STUB

\end{document}
